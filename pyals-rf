#!/usr/bin/python3 
"""
Copyright 2021-2023 Salvatore Barone <salvatore.barone@unina.it>

This is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3 of the License, or any later version.

This is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along with
RMEncoder; if not, write to the Free Software Foundation, Inc., 51 Franklin
Street, Fifth Floor, Boston, MA 02110-1301, USA.
"""
import click, git, os, sys
from git import RemoteProgress
from multiprocessing import cpu_count
from src.Classifier import Classifier
from src.ps_flow import ps_flow, ps_eval, ps_distance, ps_compare, compute_gini_dist
from src.als_flow import als_one_step, als_two_steps
from src.als_wc_flow import als_wc_one_step, als_wc_two_steps
from src.combined_flow import full_one_step, full_two_steps
from src.DtGenConfigParser import *
from src.dtgen import dtgen

def git_updater():
    try:
        print("Checking for updates...")
        restart_needed = False
        repo = git.Repo(os.path.dirname(os.path.realpath(__file__)))
        for fetch_info in repo.remotes.origin.fetch(progress=RemoteProgress()):
            print(f"Updated {fetch_info.ref} to {fetch_info.commit}")

        local_head = repo.heads[0].commit
        remote_head = repo.remotes.origin.refs[0].commit
        print(f"Local commit: {local_head}")
        print(f"Last remote commit: {remote_head}")

        for fetch_info in repo.remotes.origin.pull(repo.heads[0], progress=RemoteProgress()):
            print(f"Updated {fetch_info.ref} to {fetch_info.commit}")
            if fetch_info.commit != local_head:
                restart_needed = True
                print(f"Local head moved to {local_head}. The program will be restarted.")

        print("Checking for updates in submodules...")
        for submodule in repo.submodules:
            for fetch_info in submodule.update(init = True, recursive = True):
                print(f"Updated {fetch_info.ref} to {fetch_info.commit}")
                if fetch_info.commit != local_head:
                    restart_needed = True
                    print(f"Local head moved to {local_head}. The program will be restarted.")

        return restart_needed
    except git.exc.GitCommandError as e:
        print(e)
        return False

@click.group()
def cli():
    pass


@click.command("dump")
@click.argument('pmmlfile', type=click.Path(exists=True, dir_okay=False))
def dump(pmmlfile):
    """
    Dump the classifier and exit
    
    PMMLFILE is the PMML file describing the model
    """
    classifier = Classifier(None)
    classifier.parse(pmmlfile)
    classifier.dump()


@click.command("ps")
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
@click.option('--mode', type=click.Choice(["rank", "full"]), default = "full")
@click.option('--alpha', type=float, default = 0.07)
@click.option('--beta', type=float, default = 0.5)
@click.option('--gamma', type=float, default = 2)
@click.option("--ncpus", type = int, help = "Set the number of parallel jobs to be used turing DSE. By default, pyALS uses every CPU core.", default = cpu_count())
def bitwidth(configfile, mode, alpha, beta, gamma, ncpus):
    """
    Performs precision-scaling approximation
    
    CONFIGFILE is the path of the JSON configuration file containing all parameters which are needed to the tool.
    """
    ps_flow(configfile, mode, alpha, beta, gamma, ncpus)
    


@click.command("als")
@click.argument('approach', type = click.Choice(["whole", "split"]))
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
@click.option("--ncpus", type = int, help = "Set the number of parallel jobs to be used turing DSE. By default, pyALS uses every CPU core.", default = cpu_count())
def als(approach, configfile, ncpus):
    """
    Performs ALS approximation
    
    APPROACH can be either "whole" or "split"
    
    CONFIGFILE is the path of the JSON configuration file containing all parameters which are needed to the tool.
    """
    if approach == "whole":
        als_one_step(configfile, ncpus)
    elif approach == "split":
        als_two_steps(configfile, ncpus)
        

@click.command("als-wc")
@click.argument('approach', type = click.Choice(["whole", "split"]))
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
@click.option("--ncpus", type = int, help = "Set the number of parallel jobs to be used turing DSE. By default, pyALS uses every CPU core.", default = cpu_count())
def als_wc(approach, configfile, ncpus):
    """
    Performs ALS-WC approximation
    
    APPROACH can be either "whole" or "split"
    
    CONFIGFILE is the path of the JSON configuration file containing all parameters which are needed to the tool.
    """
    if approach == "whole":
        als_wc_one_step(configfile, ncpus)
    elif approach == "split":
        als_wc_two_steps(configfile, ncpus)
        


@click.command("full")
@click.argument('approach', type = click.Choice(["whole", "split"]))
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
@click.option("--ncpus", type = int, help = "Set the number of parallel jobs to be used turing DSE. By default, pyALS uses every CPU core.", default = cpu_count())
def full(approach, configfile, ncpus):
    """
    Performs full approximation (both ps and als)
    
    APPROACH can be either "whole" or "split"
    
    CONFIGFILE is the path of the JSON configuration file containing all parameters which are needed to the tool.
    """
    if approach == "whole":
        full_one_step(configfile, ncpus)
    elif approach == "split":
        full_two_steps(configfile, ncpus)


@click.command("learn")
@click.argument('clf', type = click.Choice(["dt", "rf", "wc"]), default = "rf")
@click.argument('dataset', type=click.Path(exists=True, dir_okay=False))
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
@click.argument('outputdir', type=click.Path(dir_okay=True), default = "output")
@click.option("-f", "--fraction", type = float, default = 0.9, help = "Fraction of data to be used as learning set. The remaining will be used as test data.")
@click.option("-d", "--depth", type = int, default = None, help = "Maximum depth of the tree(s)")
@click.option("-n", "--predictors", type = int, default = 1, help = "The number of trees in the ensemble. Ignored if clf is dt.")
@click.option("--criterion", type = click.Choice(["gini", "entropy", "log_loss"]), default = "gini", help = "The function to measure the quality of a split. Supported criteria are “gini” for the Gini impurity and “log_loss” and “entropy” both for the Shannon information gain")
@click.option("--min_sample_split", type = int, default = 2, help = "The minimum number of samples required to split an internal node.")
@click.option("--min_samples_leaf", type = int, default = 1, help = "The minimum number of samples required to be at a leaf node. A split point at any depth will only be considered if it leaves at least min_samples_leaf training samples in each of the left and right branches.")
@click.option("--max_features", default = None, help = "The number of features to consider when looking for the best split. You can also specify one between \"sqrt\", \"log2\" or \"auto\"")
@click.option("--max_leaf_nodes", type = int, default = None, help = "Grow trees with max_leaf_nodes in best-first fashion. Best nodes are defined as relative reduction in impurity. If None then unlimited number of leaf nodes.")
@click.option("--min_impurity_decrease", type = float, default = 0.0, help = "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.")
@click.option("--ccp_alpha", type = float, default = 0.0, help = "Complexity parameter used for Minimal Cost-Complexity Pruning. The subtree with the largest cost complexity that is smaller than ccp_alpha will be chosen. By default, no pruning is performed.")
@click.option("-b", "--disable_bootstrap", is_flag = True, help = "Disable the bootstrap")
def learning(clf, dataset, configfile, outputdir, fraction, depth, predictors, criterion, min_sample_split, min_samples_leaf, max_features, max_leaf_nodes, min_impurity_decrease, ccp_alpha, disable_bootstrap):
    """
    Generates a decision tree/ random forest / bagging from CSV data.

    CLF is the classifier type: "dt" stands for decision tree, "rf" for random forest, "bag" for bagging, "wc" for worst-case speculation on random-forest/bagging classifiers.

    DATASET is the csv file to be used as a learning set.

    CONFIGFILE configuration file providing further information to the tool
    
    OUTPUTDIR is the path of the output directory.
    """
    dtgen(clf, dataset, configfile, outputdir, fraction, depth, predictors, criterion, min_sample_split, min_samples_leaf, max_features, max_leaf_nodes, min_impurity_decrease, ccp_alpha, disable_bootstrap)

@click.command("eval")
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
@click.argument('axapproach', type=click.Choice(["ps", "als", "full"]))
@click.option('--axmode', type = click.Choice(["whole", "split"]))
@click.option('--nabs', type = str, required = True)
def eval(configfile, axapproach, axmode, nabs):
    if axapproach == "ps":
        ps_eval(configfile, nabs)
    else:
        print("Not supported yet")
        exit()
        
@click.command("distance")
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
@click.argument('axapproach', type=click.Choice(["ps", "als", "full"]))
@click.option('--pareto', type = click.Path(exists=True, dir_okay=False), default = None)
@click.option('--axmode', type = click.Choice(["whole", "split"]))
def distance(configfile, axapproach, pareto, axmode):
    if axapproach == "ps":
        ps_distance(configfile, pareto)
    else:
        print("Not supported yet")
        exit()

@click.command("compare")
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
@click.argument('axapproach', type=click.Choice(["ps", "als", "full"]))
@click.argument('outdir', type=click.Path(exists=True, dir_okay=True))
@click.option('--pareto', type = click.Path(exists=True, dir_okay=False), default = None)
@click.option('--axmode', type = click.Choice(["whole", "split"]))
@click.option('--alpha', type=float, default = 0.07)
@click.option('--beta', type=float, default = 0.5)
@click.option('--gamma', type=float, default = 2)
@click.option('--maxloss', type=float, default = 5)
@click.option('--neval', type = int, default = None)
def compare(configfile, axapproach, outdir, pareto, axmode, alpha, beta, gamma, maxloss, neval):
    if axapproach == "ps":
        ps_compare(configfile, outdir, pareto, alpha, beta, gamma, maxloss, neval)
    else:
        print("Not supported yet")
        exit()

@click.command("distgini")
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
@click.argument('outfile', type=click.Path(exists=False, dir_okay=False))
def compgini(configfile, outfile):
    compute_gini_dist(configfile, outfile)

cli.add_command(dump)
cli.add_command(bitwidth)
cli.add_command(als)
cli.add_command(als_wc)
cli.add_command(full)
cli.add_command(learning)
cli.add_command(eval)
cli.add_command(distance)
cli.add_command(compare)
cli.add_command(compgini)

if __name__ == '__main__':
	if git_updater():
		os.execv(sys.argv[0], sys.argv)
	else:
		cli()

