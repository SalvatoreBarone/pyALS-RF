#!/usr/bin/python3 
"""
Copyright 2021-2022 Salvatore Barone <salvatore.barone@unina.it>

This is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3 of the License, or any later version.

This is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along with
RMEncoder; if not, write to the Free Software Foundation, Inc., 51 Franklin
Street, Fifth Floor, Boston, MA 02110-1301, USA.
"""
import click, git, os, pyamosa
from pyosys import libyosys as ys
from pyalslib import check_for_file, check_for_optional_file
from src.ConfigParser import *
from src.PsConfigParser import *
from src.OneStepConfigParser import *
from src.TwoStepsConfigParser import *
from src.PsMop import *
from src.SingleStepAlsMop import *
from src.SingleStepCombined import *
from src.SecondStepAlsMop import *
from src.SecondStepCombinedMop import *


def git_updater():
    dir_path = os.path.dirname(os.path.realpath(__file__))
    repo = git.Repo(dir_path)
    repo.remotes.origin.fetch()
    local_head = repo.heads[0].commit
    remote_head = repo.remotes.origin.refs[0].commit
    if remote_head != local_head:
        print("Updating the tool...")
        repo.remotes.origin.pull()
        for submodule in repo.submodules:
            submodule.update(init = True, recursive = True)
        return True
    return False

@click.group()
def cli():
    pass


@click.command("dump")
@click.argument('pmmlfile', type=click.Path(exists=True, dir_okay=False))
def dump(pmmlfile):
    """
    Dump the classifier and exit
    
    PMMLFILE is the PMML file describing the model
    """
    classifier = Classifier(None)
    classifier.parse(pmmlfile)
    classifier.dump()


@click.command("ps")
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
def bitwidth(configfile):
    """
    Performs precision-scaling approximation
    
    CONFIGFILE is the path of the JSON configuration file containing all parameters which are needed to the tool.
    """
    ps_flow(configfile)
    


@click.command("als")
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
@click.option("-1", "--onestep", is_flag = True, help = "Enables the one-step approximation flow")
def als(configfile, onestep):
    """
    Performs ALS approximation
    
    CONFIGFILE is the path of the JSON configuration file containing all parameters which are needed to the tool.
    """
    if onestep:
        als_one_step(configfile)
    else:
        als_two_steps(configfile)


@click.command("full")
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
@click.option("-1", "--onestep", is_flag = True, help = "Enables the one-step approximation flow")
def full(configfile, onestep):
    """
    Performs full approximation (both ps and als)
    
    CONFIGFILE is the path of the JSON configuration file containing all parameters which are needed to the tool.
    """
    if onestep:

    configuration = OneStepConfigParser(configfile)
    check_for_file(configuration.pmml)
    check_for_file(configuration.error_conf.test_dataset)
    check_for_file(configuration.als_conf.lut_cache)
    if configuration.outdir != ".":
        mkpath(configuration.outdir)
    classifier = Classifier(configuration.als_conf)
    classifier.parse(configuration.pmml)
    classifier.generate_hdl_exact_implementations(configuration.outdir)
    problem = SingleStepCombined(classifier, configuration.error_conf.test_dataset)
    optimizer = pyamosa.Optimizer(configuration.optimizer_conf)
    improve = None
    if os.path.exists(f"{configuration.outdir}/final_archive.json"):
        print("Using results from previous runs as a starting point.")
        improve = f"{configuration.outdir}/final_archive.json"
    optimizer.hill_climb_checkpoint_file = f"{configuration.outdir}/{optimizer.hill_climb_checkpoint_file}"
    optimizer.minimize_checkpoint_file = f"{configuration.outdir}/{optimizer.minimize_checkpoint_file}"
    optimizer.cache_dir = f"{configuration.outdir}/{optimizer.cache_dir}"
    optimizer.run(problem, improve)
    optimizer.archive_to_csv(problem, f"{configuration.outdir}/report.csv")
    optimizer.plot_pareto(problem, f"{configuration.outdir}/pareto_front.pdf")
    optimizer.archive_to_json(f"{configuration.outdir}/final_archive.json")
    classifier.generate_hdl_onestep_full_ax_implementations(configuration.outdir, optimizer.pareto_set())
    print(f"All done! Take a look at the {configuration.outdir} directory.")


@click.command("als-twosteps")
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
def als_twosteps(configfile):
    """
    Performs two-steps ALS approximation
    
    CONFIGFILE is the path of the JSON configuration file containing all parameters which are needed to the tool.
    """
    configuration = TwoStepsConfigParser(configfile)
    check_for_file(configuration.pmml)
    check_for_file(configuration.error_conf.test_dataset)
    check_for_file(configuration.als_conf.lut_cache)
    check_for_optional_file(configuration.error_conf.dataset)
    if configuration.outdir != ".":
        mkpath(configuration.outdir)
    classifier = Classifier(configuration.als_conf)
    print("Creating classifier object...")
    classifier.parse(configuration.pmml)
    print("PMML parsing completed")
    classifier.generate_hdl_exact_implementations(configuration.outdir)
    print("HDL generation (accurate) completed")
    problem = SecondStepOptimizerAlsOnly(classifier, configuration.error_conf.test_dataset, TwoStepsOptimizerConf(error_conf_1, amosa_conf_1, error_conf_2, amosa_conf_2), improve, output)
    print("Assertion generation (approximate) completed")
    optimizer = pyamosa.Optimizer(configuration.snd_optimizer_conf)
    optimizer.hill_climb_checkpoint_file = f"{configuration.outdir}/second_step_hillclimb_checkpoint.json"
    optimizer.minimize_checkpoint_file = f"{configuration.outdir}/second_step_hminimize_checkpoint.json"
    optimizer.cache_dir = f"{configuration.outdir}/.second_step_cache"
    optimizer.run(problem)
    optimizer.archive_to_csv(problem, f"{configuration.outdir}/report.csv")
    optimizer.plot_pareto(problem, f"{configuration.outdir}/pareto_front.pdf")
    optimizer.archive_to_json(f"{configuration.outdir}/final_archive.json")
    classifier.generate_hdl_twostep_asl_ax_implementations(configuration.outdir, optimizer.pareto_set(), problem.opt_solutions_for_trees)
    print(f"All done! Take a look at the {configuration.outdir} directory.")


@click.command("full-twosteps")
@click.argument('configfile', type=click.Path(exists=True, dir_okay=False))
def full_twosteps(configfile):
    """
    Performs two-steps full approximation (both ps and als)

    CONFIGFILE is the path of the JSON configuration file containing all parameters which are needed to the tool.
    """
    configuration = TwoStepsConfigParser(configfile)
    check_for_file(configuration.pmml)
    check_for_file(configuration.error_conf.test_dataset)
    check_for_file(configuration.als_conf.lut_cache)
    check_for_optional_file(configuration.error_conf.dataset)
    if configuration.outdir != ".":
        mkpath(configuration.outdir)
    classifier = Classifier(configuration.als_conf)
    classifier.parse(configuration.pmml)
    classifier.generate_hdl_exact_implementations(configuration.outdir)
    problem = SecondStepOptimizerCombined(classifier, configuration.error_conf.test_dataset, TwoStepsOptimizerConf(error_conf_1, amosa_conf_1, error_conf_2, amosa_conf_2), improve, output)
    optimizer = pyamosa.Optimizer(configuration.snd_optimizer_conf)
    optimizer.hill_climb_checkpoint_file = f"{configuration.outdir}/second_step_hillclimb_checkpoint.json"
    optimizer.minimize_checkpoint_file = f"{configuration.outdir}/second_step_hminimize_checkpoint.json"
    optimizer.cache_dir = f"{configuration.outdir}/.second_step_cache"
    optimizer.run(problem)
    optimizer.archive_to_csv(problem, f"{configuration.outdir}/report.csv")
    optimizer.plot_pareto(problem, f"{configuration.outdir}/pareto_front.pdf")
    optimizer.archive_to_json(f"{configuration.outdir}/final_archive.json")
    classifier.generate_hdl_twostep_full_ax_implementations(configuration.outdir, optimizer.pareto_set(), problem.opt_solutions_for_trees)
    print(f"All done! Take a look at the {configuration.outdir} directory.")


cli.add_command(dump)
cli.add_command(bitwidth)
cli.add_command(als_onestep)
cli.add_command(als_twosteps)
cli.add_command(full_onestep)
cli.add_command(full_twosteps)

if __name__ == '__main__':
	#if git_updater():
	#	os.execv(sys.argv[0], sys.argv)
	#else:
		design = ys.Design()
		ys.run_pass("plugin -i ghdl", design)
		cli()

